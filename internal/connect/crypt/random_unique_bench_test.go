// SPDX-FileCopyrightText: 2024 Melg Eight <public.melg8@gmail.com>
//
// SPDX-License-Identifier: MIT

package crypt

import (
	"maps"
	"math/rand/v2"
	"slices"
	"sort"
	"testing"
	"time"
)

// Generates n random values, no uniqueness guarantee.
// Can be used as benchmarking baseline of fastest algorithms.
func randnBaseline(n int) []int {
	if n <= 0 {
		return nil
	}

	uniq := make([]int, n)
	for i := 0; i < n; i++ {
		uniq[i] = rand.Int() //nolint:gosec
	}

	return uniq
}

// UniqRandn1 generates n unique random values using a map for uniqueness check
// and then collecting the keys of the map into a slice.
func UniqRandn1(n int) []int {
	if n <= 0 {
		return []int{}
	}
	unique := make(map[int]struct{}, n)
	for len(unique) < n {
		value := rand.Int() //nolint:gosec
		unique[value] = struct{}{}
	}

	return slices.Collect(maps.Keys(unique))
}

// UniqRandn11 generates n unique random values using a map for uniqueness check
// and then collecting the keys of the map into a slice.
// The keys are iterated over and copied into prealocated slice.
func UniqRandn11(n int) []int {
	if n <= 0 {
		return []int{}
	}
	unique := make(map[int]struct{}, n)
	for len(unique) < n {
		value := rand.Int() //nolint:gosec
		unique[value] = struct{}{}
	}
	keys := maps.Keys(unique)
	result := make([]int, n)
	i := 0
	for key := range keys {
		result[i] = key
		i++
	}

	return result
}

// UniqRandn2 generates n unique random values using a map for uniqueness check
// and then appending new values to a slice.
func UniqRandn2(n int) []int {
	if n <= 0 {
		return nil
	}

	uniq := make([]int, 0, n)
	seen := make(map[int]struct{}, n)
	for len(uniq) < n {
		val := rand.Int() //nolint:gosec
		if _, exists := seen[val]; exists {
			continue
		}
		seen[val] = struct{}{}
		uniq = append(uniq, val)
	}

	return uniq
}

// UniqRandn2 generates n unique random values using a map for uniqueness check
// and then copying new values into prealocated slice.
func UniqRandn21(n int) []int {
	if n <= 0 {
		return nil
	}

	uniq := make([]int, n)
	seen := make(map[int]struct{}, n)
	pos := 0
	var val int
	seenValue := struct{}{}
	for pos < n {
		val = rand.Int() //nolint:gosec
		if _, exists := seen[val]; exists {
			continue
		}
		seen[val] = seenValue
		uniq[pos] = val
		pos++
	}

	return uniq
}

func Unique[T comparable](xs []T) []T {
	n := len(xs)
	if n == 0 {
		return xs
	}
	j := 0
	for i := 1; i < n; i++ {
		if xs[j] != xs[i] {
			j++
			if j < i {
				xs[j] = xs[i]
				for k := i + 1; k < n; k++ {
					if xs[j] != xs[k] {
						j++
						xs[j] = xs[k]
					}
				}

				break
			}
		}
	}
	xs = xs[0 : j+1]

	return xs
}

// UniqRandn4 generates n unique random values by aggregating them into slice,
// sorting slice and deduplicating it until slice has n unique elements in it.
func UniqRandn4(n int) []int {
	if n <= 0 {
		return nil
	}

	uniq := make([]int, n)
	generatedN := 0

	for generatedN < n {
		for i := generatedN; i < n; i++ {
			uniq[i] = rand.Int() //nolint:gosec
		}
		sort.Ints(uniq)
		uniq = Unique(uniq)
		generatedN = len(uniq)
	}

	return uniq
}

type RandomSequenceOfUnique struct {
	mIndex              uint32
	mIntermediateOffset uint32
}

func permuteQPR(x uint32) uint32 {
	const prime = 4294967291
	if x >= prime {
		return x // The 5 integers out of range are mapped to themselves.
	}
	residue := uint32((uint64(x) * uint64(x)) % prime) //nolint:gosec
	if x <= prime/2 {
		return residue
	}

	return prime - residue
}

func NewRandomSequenceOfUnique(seedBase, seedOffset uint32) RandomSequenceOfUnique {
	return RandomSequenceOfUnique{
		mIndex:              permuteQPR(permuteQPR(seedBase) + 0x682f0161),
		mIntermediateOffset: permuteQPR(permuteQPR(seedOffset) + 0x46790905),
	}
}

func (r *RandomSequenceOfUnique) Next() uint32 {
	result := permuteQPR((permuteQPR(r.mIndex) + r.mIntermediateOffset) ^ 0x5bf03635)
	r.mIndex++

	return result
}

// UniqRandn5 generates n unique random values by using a random sequence of
// unique uint32s.
//
// This function uses a random sequence of unique uint32s to generate unique
// random values. The sequence is generated by using a seed that is based on the
// current unix time.
//
// The resulting slice has n unique random values in it.
func UniqRandn5(n int) []int {
	if n <= 0 {
		return nil
	}

	uniq := make([]int, n)
	unixTimeSeed := uint32(time.Now().Unix()) //nolint:gosec
	rsu := NewRandomSequenceOfUnique(unixTimeSeed, unixTimeSeed+1)

	for i := 0; i < n; i++ {
		uniq[i] = int(rsu.Next())
	}

	return uniq
}

// benchmarkUniqRandn runs a benchmark for a function that generates a
// slice of n unique random values.
//
// The function is called b.N times, and each time it is called with n=100_000.
// The length of the resulting slice is checked to make sure it is equal to
// 100_000.
func benchmarkUniqRandn(b *testing.B, fn func(int) []int) {
	b.Helper()
	for n := 0; n < b.N; n++ {
		nElements := 100_000
		res := fn(nElements)
		if len(res) != nElements {
			b.Fatal("length is not ", nElements)
		}
	}
}

// No uniqueness guarantee, just random values generation.
func BenchmarkRandnBaseline(b *testing.B) {
	benchmarkUniqRandn(b, randnBaseline)
}

func BenchmarkUniqRandn1(b *testing.B) {
	benchmarkUniqRandn(b, UniqRandn1)
}

func BenchmarkUniqRandn11(b *testing.B) {
	benchmarkUniqRandn(b, UniqRandn11)
}

func BenchmarkUniqRandn2(b *testing.B) {
	benchmarkUniqRandn(b, UniqRandn2)
}

func BenchmarkUniqRandn21(b *testing.B) {
	benchmarkUniqRandn(b, UniqRandn21)
}

func BenchmarkUniqRandn4(b *testing.B) {
	benchmarkUniqRandn(b, UniqRandn4)
}

func BenchmarkUniqRandn5(b *testing.B) {
	benchmarkUniqRandn(b, UniqRandn5)
}
